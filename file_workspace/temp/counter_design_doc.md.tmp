# `counter` 模块设计文档

---

## 1. 模块概述

### 功能描述  
`counter` 是一个 **8位上升沿触发的同步递增计数器**，支持 **同步复位** 和 **计数使能控制**。该模块在每个时钟上升沿根据 `reset` 和 `enable` 信号的状态更新其内部计数值。当复位信号有效时，计数器清零；当使能信号有效且未复位时，计数器递增；否则保持当前值。

### 设计目标
- 实现一个资源高效、可复用的 8 位递增计数器。
- 支持同步复位机制，确保与系统时钟同步，避免异步复位带来的时序问题。
- 提供使能控制功能，允许在不中断时钟的情况下暂停计数。
- 适用于通用数字系统中的定时、状态控制、数据流管理等场景。

---

## 2. 接口说明

### 端口列表

| 端口名   | 方向 | 位宽 | 类型     | 描述 |
|---------|------|------|----------|------|
| `clk`    | 输入 | 1    | `wire`   | 主时钟信号，上升沿触发内部状态更新 |
| `reset`  | 输入 | 1    | `wire`   | 同步复位信号，高电平有效。当为高时，在下一个时钟上升沿将计数器清零 |
| `enable` | 输入 | 1    | `wire`   | 计数使能信号，高电平允许递增计数 |
| `count`  | 输出 | 8    | `reg [7:0]` | 当前计数值输出，范围为 0 到 255（8'd0 ~ 8'd255） |

### 信号详细说明

| 信号 | 有效电平 | 时序行为 | 备注 |
|------|----------|----------|------|
| `clk`    | 上升沿触发 | 所有操作均在 `posedge clk` 时发生 | 推荐使用全局时钟网络 |
| `reset`  | 高电平有效 | 同步复位：仅在 `clk↑` 且 `reset == 1` 时清零 | 不影响时钟运行 |
| `enable` | 高电平有效 | 仅当 `reset == 0` 且 `enable == 1` 时递增 | 可动态启停计数 |
| `count`  | —— | 寄存器输出，非阻塞赋值更新 | 值在时钟上升沿后稳定 |

---

## 3. 功能规格

### 状态转移逻辑

| `reset` | `enable` | 行为描述 |
|--------|----------|----------|
| 1      | X        | 在下一个时钟上升沿，`count <= 8'd0`（清零） |
| 0      | 1        | 在下一个时钟上升沿，`count <= count + 1`（递增） |
| 0      | 0        | 在下一个时钟上升沿，`count <= count`（保持不变） |

> **注意**：所有操作均为同步行为，必须依赖 `clk` 上升沿。

### 计数范围
- 最小值：`8'd0`（0）
- 最大值：`8'd255`（255）
- 溢出处理：达到 `255` 后继续递增将回绕至 `0`（自然溢出，无额外标志位）

### 特性总结
- **位宽固定**：8 位无符号计数
- **触发方式**：上升沿触发（`posedge clk`）
- **复位类型**：同步复位（节省面积，利于时序收敛）
- **使能机制**：条件递增，便于功耗控制和流程调度

---

## 4. 设计架构

### 内部结构图（文字描述）

```
+------------------+
|                 ▲
|     +-------+   | clk (posedge)
|     |       |   |
|     | Reg   |<--+-- count [7:0]
|     |       |
|     +---▲---+
|         |
|         | next_count
|     +---▼-------+
|     |           |
|     | Combinational Logic
|     | - if reset: 8'd0
|     | - else if enable: count + 1
|     | - else: count
|     +-----------+
|                 ▲
|   reset ────────┤
|   enable ───────┤
+------------------+
```

### 关键组件说明

- **寄存器 (`count`)**：存储当前计数值，使用非阻塞赋值（`<=`）保证时序逻辑正确性。
- **组合逻辑块**：决定下一状态值，嵌套在 `always @(posedge clk)` 块中。
- **同步控制逻辑**：通过 `if-else` 结构实现优先级控制（复位 > 使能 > 保持）。

### Verilog 实现关键点
```verilog
always @(posedge clk) begin
    if (reset)
        count <= 8'd0;
    else if (enable)
        count <= count + 1;
end
```
- 使用 **非阻塞赋值** 确保多个寄存器并行更新。
- 条件判断顺序体现优先级：复位优先于使能。
- 缺省分支隐式保持原值，无需显式写出。

---

## 5. 时序要求

### 时钟约束
- **时钟频率**：由目标系统决定，建议不超过综合后时序分析允许的最大频率。
- **时钟抖动/偏移**：应满足标准时序收敛要求（如 setup/hold time）。
- **推荐时钟源**：连接到 FPGA 全局时钟缓冲器（如 IBUF-GCLK），以减少 skew。

### 复位信号要求
- **同步复位**：`reset` 必须与时钟 `clk` 同步。
- **建立与保持时间**：`reset` 信号需满足相对于 `clk` 上升沿的建立（setup）和保持（hold）时间。
- **脉冲宽度**：建议至少维持一个完整时钟周期高电平，确保可靠捕获。

### 时序路径关键点
| 路径类型 | 源 | 目标 | 约束建议 |
|--------|----|------|----------|
| 数据路径 | `count` reg → ALU (+1) → `count` reg | 内部组合延迟 | 满足 `T_clk → Q + T_comb + T_setup < T_cycle` |
| 复位路径 | `reset` 输入 → 触发器控制端 | 同步捕获 | 需同步寄存（可选前置同步器） |

> ⚠️ **警告**：若 `reset` 来自异步源（如按键），建议添加两级同步寄存器以防止亚稳态。

---

## 6. 使用说明

### 实例化示例

```verilog
// 实例化 counter 模块
counter u_counter (
    .clk    (clk),        // 输入：系统时钟
    .reset  (reset_sync), // 输入：同步复位信号
    .enable (cnt_en),     // 输入：计数使能
    .count  (current_cnt) // 输出：当前计数值
);
```

### 参数配置说明
- 本模块为固定 8 位设计，不可参数化。
- 如需不同位宽，请参考此设计进行修改或使用参数化版本（见扩展建议）。

### 注意事项
1. **避免异步复位直接接入**：若 `reset` 来自异步域，必须先同步化。
2. **使能信号去抖动**：对于手动控制的 `enable`，建议加入消抖逻辑。
3. **溢出检测**：本模块不提供溢出标志。如需检测溢出，请外部比较 `count == 8'hFF && enable == 1`。
4. **初始化建议**：上电后建议通过 `reset` 显式清零，确保初始状态明确。

---

## 7. 测试建议

### 测试策略

| 测试项 | 目标 | 方法 |
|-------|------|------|
| 基本计数功能 | 验证递增逻辑 | 施加连续时钟，`reset=0`, `enable=1`，观察 `count` 是否逐拍递增 |
| 同步复位功能 | 验证复位有效性 | 在任意时刻拉高 `reset`，确认下一周期 `count=0` |
| 使能控制功能 | 验证暂停/恢复能力 | 交替切换 `enable`，确认计数仅在使能期间递增 |
| 溢出回绕测试 | 验证 255→0 正确性 | 从 `254` 开始持续使能，检查 `255` 后是否变为 `0` |
| 边界时序测试 | 验证 setup/hold 满足性 | 在复位或使能跳变沿附近施加信号，验证无亚稳态 |

### 示例测试平台（Testbench）

```verilog
module tb_counter;

    reg clk;
    reg reset;
    reg enable;
    wire [7:0] count;

    // 实例化被测模块
    counter uut (
        .clk    (clk),
        .reset  (reset),
        .enable (enable),
        .count  (count)
    );

    // 生成时钟（10ns 周期）
    always begin
        clk = 0; #5;
        clk = 1; #5;
    end

    initial begin
        $dumpfile("counter.vcd");
        $dumpvars(0, tb_counter);

        // 初始化输入
        reset  = 0;
        enable = 0;

        #10 reset = 1;           // 同步复位
        #20 reset = 0;           // 释放复位
        #10 enable = 1;          // 启动计数
        #160 enable = 0;         // 暂停计数
        #40 enable = 1;          // 继续计数
        #100 $finish;            // 结束仿真
    end

    // 监控输出
    initial begin
        $monitor("Time=%0t | clk=%b reset=%b enable=%b | count=%d", 
                 $time, clk, reset, enable, count);
    end

endmodule
```

### 预期输出片段
```
Time=0   | clk=0 reset=0 enable=0 | count=x
Time=10  | clk=1 reset=1 enable=0 | count=0
Time=30  | clk=1 reset=0 enable=0 | count=0
Time=40  | clk=1 reset=0 enable=1 | count=1
Time=50  | clk=1 reset=0 enable=1 | count=2
...
```

### 验证要点
- 复位后 `count` 是否立即（下周期）归零？
- 使能关闭期间 `count` 是否保持不变？
- 连续递增是否无跳变或停滞？
- 溢出是否正确回绕至 `0`？

---

## 附录：扩展建议

### 参数化版本（可选改进）
```verilog
module counter_generic #(
    parameter WIDTH = 8
)(
    input               clk,
    input               reset,
    input               enable,
    output reg [WIDTH-1:0] count
);

    always @(posedge clk) begin
        if (reset)
            count <= {WIDTH{1'b0}};
        else if (enable)
            count <= count + 1;
    end

endmodule
```

> 使用 `WIDTH` 参数可适配不同位宽需求，提升模块复用性。

---

**文档版本**：1.0  
**最后更新**：2025年4月5日  
**作者**：Verilog 设计文档生成系统  
**版权**：开放使用，适用于工程参考与教学用途